import React, { useState, useRef, useEffect } from 'react';

const ScratchGame = () => {
  const quotes = [
    {
      text: "Pravda a l√°ska mus√≠ zv√≠tƒõzit nad l≈æ√≠ a nen√°vist√≠.",
      author: "‚Äî V√°clav Havel",
      category: "Pravda"
    },
    {
      text: "Svoboda se ned√°v√°, svobodu si ƒçlovƒõk mus√≠ z√≠skat.",
      author: "‚Äî Tom√°≈° Garrigue Masaryk",
      category: "Svoboda"
    },
    {
      text: "Demokracie nen√≠ stav, ale proces.",
      author: "‚Äî V√°clav Havel",
      category: "Demokracie"
    },
    {
      text: "Lid√©, kte≈ô√≠ chtƒõj√≠ svobodu, jsou lid√©, kte≈ô√≠ jsou ochotni n√©st odpovƒõdnost.",
      author: "‚Äî V√°clav Havel",
      category: "Odpovƒõdnost"
    },
    {
      text: "Kdy≈æ se lid√© spojuj√≠ pro spoleƒçn√© dobro, ≈æ√°dn√° s√≠la je nem≈Ø≈æe zastavit.",
      author: "‚Äî V√°clav Havel",
      category: "Jednota"
    },
    {
      text: "Odvaha se projevuje v mal√Ωch ka≈ædodenn√≠ch rozhodnut√≠ch, ne jen ve velk√Ωch ƒçinech.",
      author: "‚Äî V√°clav Havel",
      category: "Odvaha"
    },
    {
      text: "Nejvƒõt≈°√≠ s√≠la ƒçlovƒõka spoƒç√≠v√° ve schopnosti jednat v souladu s vlastn√≠mi hodnotami.",
      author: "‚Äî V√°clav Havel",
      category: "Hodnoty"
    }
  ];

  const [currentQuoteIndex, setCurrentQuoteIndex] = useState(0);
  const [progress, setProgress] = useState(0);
  const [isRevealed, setIsRevealed] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);
  const canvasRef = useRef(null);
  const [isDrawing, setIsDrawing] = useState(false);

  const currentQuote = quotes[currentQuoteIndex];

  useEffect(() => {
    initCanvas();
  }, [currentQuoteIndex]);

  const initCanvas = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    // ƒåern√° cenzura s v√≠ce vrstvami
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Vrstva 1 - tmavƒõ ≈°ed√°
    ctx.fillStyle = '#1a1a1a';
    for (let i = 0; i < 100; i++) {
      ctx.fillRect(
        Math.random() * canvas.width,
        Math.random() * canvas.height,
        Math.random() * 5 + 2,
        Math.random() * 5 + 2
      );
    }

    // Vrstva 2 - st≈ôedn√≠ ≈°ed√°
    ctx.fillStyle = '#333333';
    for (let i = 0; i < 80; i++) {
      ctx.fillRect(
        Math.random() * canvas.width,
        Math.random() * canvas.height,
        Math.random() * 4 + 1,
        Math.random() * 4 + 1
      );
    }

    // Vrstva 3 - svƒõtlej≈°√≠ textura
    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
    for (let i = 0; i < 60; i++) {
      ctx.fillRect(
        Math.random() * canvas.width,
        Math.random() * canvas.height,
        Math.random() * 3,
        Math.random() * 3
      );
    }

    setProgress(0);
    setIsRevealed(false);
    setShowSuccess(false);
  };

  const scratch = (x, y) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    const posX = (x - rect.left) * scaleX;
    const posY = (y - rect.top) * scaleY;

    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    ctx.arc(posX, posY, 30, 0, Math.PI * 2);
    ctx.fill();

    calculateProgress();
  };

  const handleMouseDown = (e) => {
    setIsDrawing(true);
    scratch(e.clientX, e.clientY);
  };

  const handleMouseMove = (e) => {
    if (isDrawing) {
      scratch(e.clientX, e.clientY);
    }
  };

  const handleMouseUp = () => {
    setIsDrawing(false);
  };

  const handleTouchStart = (e) => {
    e.preventDefault();
    setIsDrawing(true);
    const touch = e.touches[0];
    scratch(touch.clientX, touch.clientY);
  };

  const handleTouchMove = (e) => {
    e.preventDefault();
    if (isDrawing) {
      const touch = e.touches[0];
      scratch(touch.clientX, touch.clientY);
    }
  };

  const handleTouchEnd = () => {
    setIsDrawing(false);
  };

  const calculateProgress = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const pixels = imageData.data;

    let transparent = 0;
    for (let i = 3; i < pixels.length; i += 4) {
      if (pixels[i] < 128) transparent++;
    }

    const percent = Math.round((transparent / (pixels.length / 4)) * 100);
    setProgress(percent);

    if (percent > 90 && !isRevealed) {
      setIsRevealed(true);
      setShowSuccess(true);
      setTimeout(() => {
        setShowSuccess(false);
        nextQuote();
      }, 2000);
    }
  };

  const resetCanvas = () => {
    initCanvas();
  };

  const nextQuote = () => {
    setCurrentQuoteIndex((prev) => (prev + 1) % quotes.length);
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-900 to-blue-700 flex items-center justify-center p-5">
      <div className="max-w-4xl w-full">
        <div className="text-center text-white mb-8">
          <h1 className="text-5xl font-bold mb-3 drop-shadow-lg">üïäÔ∏è Se≈°krabej cenzuru</h1>
          <p className="text-xl opacity-90">P≈ôejeƒè my≈°√≠ nebo prstem p≈ôes ƒçernou cenzuru a odhal skryt√© cit√°ty</p>
        </div>

        <div className="bg-white rounded-3xl p-10 shadow-2xl relative overflow-hidden">
          <span className="inline-block bg-red-500 text-white px-4 py-1 rounded-full text-sm mb-4">
            {currentQuote.category}
          </span>

          <div className="relative min-h-[250px] flex items-center justify-center">
            <div className="text-center px-5 py-8">
              <p className="text-3xl leading-relaxed text-gray-800 mb-5">
                {currentQuote.text}
              </p>
              <p className="text-xl text-gray-500 italic">
                {currentQuote.author}
              </p>
            </div>

            <canvas
              ref={canvasRef}
              className="absolute top-0 left-0 w-full h-full cursor-grab active:cursor-grabbing"
              onMouseDown={handleMouseDown}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              onMouseLeave={handleMouseUp}
              onTouchStart={handleTouchStart}
              onTouchMove={handleTouchMove}
              onTouchEnd={handleTouchEnd}
            />

            {showSuccess && (
              <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-green-500 text-white px-12 py-8 rounded-2xl text-3xl font-bold shadow-2xl z-20 animate-bounce">
                Odhaleno! Z√≠sk√°v√°≈° p√≠smeno L
              </div>
            )}
          </div>

          <div className="mt-8">
            <div className="bg-gray-200 h-5 rounded-full overflow-hidden">
              <div
                className="h-full bg-gradient-to-r from-blue-500 to-green-500 rounded-full transition-all duration-300"
                style={{ width: `${progress}%` }}
              />
            </div>
            <p className="text-center mt-2 text-gray-600 text-sm">
              Odkryto: {progress}%
            </p>
          </div>

          <div className="flex gap-4 mt-6 justify-center flex-wrap">
            <button
              onClick={resetCanvas}
              className="bg-gradient-to-r from-purple-600 to-purple-800 text-white px-6 py-3 rounded-full font-medium shadow-lg hover:scale-105 transform transition"
            >
              Zkusit znovu
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ScratchGame;
